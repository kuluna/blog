<!doctype html>
<html lang="ja">
<head>
  <title>TypeScriptでpromiseをawaitしながらcatchもする - kuluna.class</title>  
  <meta name="description" content="Build any languages, Run anywhere.">
  <link rel="icon" href="https://kuluna.github.io/blog/favicon.ico">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css">
  <link rel="stylesheet" href="https://kuluna.github.io/blog/css/syntax.css">
  <link rel="stylesheet" href="https://kuluna.github.io/blog/css/theme.css">
</head>
<body>
<header class="mdc-toolbar">
  <div class="mdc-toolbar__row">
    <section class="mdc-toolbar__section mdc-toolbar__section--align-start">
      <span class="mdc-toolbar__title"><a href="https://kuluna.github.io/blog/" class="title-link">kuluna.class</a></span>
    </section>
  </div>
</header>


<main>
  <nav>
    <a href="javascript:history.back();" class="mdc-button" data-mdc-auto-init="MDCRipple">BACK</a>
  </nav>

  <article class="mdc-card mdc-elevation--z6 default-padding">
    <header>
      <h1 class="entry-title">TypeScriptでpromiseをawaitしながらcatchもする</h1>
      <p class="entry-date">2017-09-04 09:22:43 &#43;0900 JST</p>
      <p>
        Categories:
        
          <a href="../../categories/angular">Angular</a>
        
          <a href="../../categories/typescript">TypeScript</a>
        
      </p>
      
      <div class="socials">
        
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="kuluna">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        
        <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
        
        <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="en">Pocket</a>
        <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
      </div>
    </header>

    <p>

<p>TypeScriptには戻り値がpromiseの関数をC#のTaskのようにasync/awaitで書くことができます。<br />
これによってコールバック地獄がなくなり、コードもまるで同期処理のときのようにすっきりさせることができます。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// これが
</span><span class="c1"></span><span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span><span class="p">;</span>
  <span class="nx">b</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="nx">res</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// こうなる
</span><span class="c1"></span><span class="kr">async</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">b</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<p>こんな感じですね。すてき！</p>

<h1 id="await中にcatchを使う">await中にcatchを使う</h1>

<p>promiseをJavascriptで使うときは、成功時のthenとエラー時のcatchの2つのコールバックが利用できます。TypeScriptのawaitでは成功時はそのまま戻り値を格納することができますが、エラー時はそこで処理が止まってしまいます。<br />
これを回避するにはC#と同じく<code>try-catch</code>で囲ってあげる必要がありました。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">b</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>うーんこの感じ。</p>

<p>しかし、これを<code>try-catch</code>を使わずにエラー処理もできるようにする方法があります。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">b</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span></code></pre></div>
<p>これはTypeScriptの共用体型(Union type)の機能によって実現できる書き方です。共用体型とは、2つ以上の型の特性を持たせることができる特殊な型で、元々型をもっていないJavaScriptのスーパーセットならではの機能です。</p>

<p>例えば、</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="k">const</span> <span class="nx">start</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">number</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">;</span>
<span class="k">const</span> <span class="nx">end</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span></code></pre></div>
<p>といったように、stringとnumberの共用体型はそのどちらも受け入れることができます。<br />
ただし、この場合は足し算のような計算をさせることができません。なぜならnumberの可能性と同時にstringの可能性もあるからです。</p>

<p>同じように、</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">b</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span></code></pre></div>
<p>これもpromiseによって返される値の型とcatchの戻り値、即ち上の場合void型の共用体型となります。<br />
このvoidが厄介で、voidの可能性があるということはresultに対して何もできない(プロパティのアクセスすらできない)状態になります。</p>

<h1 id="catchでpromiseと同じ型の値を返す">catchでpromiseと同じ型の値を返す</h1>

<p>そこで解決策として、<code>await b()</code>の戻り値の型と<code>catch()</code>の戻り値の型を同じにしてあげれば共用体型でなくなり、resultにアクセスできるようになります。</p>

<p>仮にb()の戻り値が<code>Promise&lt;number&gt;</code>だった場合は、</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">b</span><span class="p">().</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// hogehoge
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>とすることで、resultの型がnumberになります。</p>

<p>型があるという安心感、プライスレス。</p>
</p>

  </article>
  <nav>
    <a href="https://kuluna.github.io/blog/" class="mdc-button" data-mdc-auto-init="MDCRipple">TOP</a>
  </nav>
</main>

<script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
<script>window.mdc.autoInit();</script>
</body>
</html>

